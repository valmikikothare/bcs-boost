<?php
namespace App\Http\Controllers;

use App\Mail\LeadApprovedMail;
use App\Mail\LeadRejectedMail;
use App\Models\BookingHistory;
use App\Models\CancellationMail;
use App\Models\CancellationRequest;
use App\Models\SessionLeads;
use App\Models\Slot;
use App\Models\User;
use Carbon\Carbon;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\View;

class SlotController extends Controller
{
    public function index()
    {
        $today = Carbon::today();
        $slots = Slot::with(['sessionLeads', 'approvedLead.user'])
            ->withCount('bookinghistory')
            ->orderByRaw('ABS(DATEDIFF(date, ?))', [$today])
            ->get();

        return view('slots.index', compact('slots'));
    }

    public function view_attendees($id)
    {
        $attendees_list = Slot::where('id', $id)->with(['bookinghistory', 'bookinghistory.user'])->first();
        return view('slots.view_attendees', compact(
            'attendees_list',
        ));
    }

    // Show the form for creating a new slot
    public function create()
    {
        return view('slots.create');
    }

    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name'            => 'required|string|max:255',
            'date'            => 'required',
            'start_time'      => 'required',
            'end_time'        => [
                'required',
                function ($attribute, $value, $fail) use ($request) {
                    // Convert both start time and end time to Carbon instances using the m-d-Y date
                    try {
                        $startDateTime = \Carbon\Carbon::createFromFormat('m-d-Y h:i A', $request->date . ' ' . $request->start_time);
                        $endDateTime   = \Carbon\Carbon::createFromFormat('m-d-Y h:i A', $request->date . ' ' . $value);

                        // Ensure the end time is greater than the start time
                        if ($endDateTime->lte($startDateTime)) {
                            $fail('The end time must be after the start time.');
                        }
                    } catch (\Exception $e) {
                        // Catch any exceptions related to date/time formatting
                        $fail('Invalid date/time format.');
                    }
                },
            ],
            'no_of_attendees' => 'required|integer|min:1',
        ]);

        if ($validator->fails()) {
            return response()->json(['errors' => $validator->errors()], 422);
        }

        // Convert the date from m-d-Y to Y-m-d
        $date = \Carbon\Carbon::createFromFormat('m-d-Y', $request->date)->format('Y-m-d');

        // Convert start time and end time to 24-hour format (HH:mm:ss)
        $start_time = \Carbon\Carbon::createFromFormat('h:i A', $request->start_time)->format('H:i:s');
        $end_time   = \Carbon\Carbon::createFromFormat('h:i A', $request->end_time)->format('H:i:s');

        // Merge the converted values into the request
        $request->merge([
            'date'       => $date,
            'start_time' => $start_time,
            'end_time'   => $end_time,
        ]);

        // Create the new Slot entry
        Slot::create($request->all());

        return response()->json(['success' => true]);
    }

    // Show the form for editing a specific slot
    public function edit(Slot $slot)
    {
        return response()->json([
            'slot' => [
                'id'              => $slot->id,
                'name'            => $slot->name,
                'date'            => $slot->date,
                'start_time'      => $slot->start_time,
                'end_time'        => $slot->end_time,
                'no_of_attendees' => $slot->no_of_attendees,
            ],
        ]);
    }

    public function update(Request $request, $id)
    {
        // Validate the incoming data
        $validator = Validator::make($request->all(), [
            'name'            => 'required|string|max:255',
            'date'            => 'required|date_format:m-d-Y', // Expecting m-d-Y format
            'start_time'      => 'required',
            'end_time'        => [
                'required',
                function ($attribute, $value, $fail) use ($request) {
                    // Convert both start time and end time to 24-hour format before comparison
                    $startDateTime = \Carbon\Carbon::createFromFormat('m-d-Y h:i A', $request->date . ' ' . $request->start_time);
                    $endDateTime   = \Carbon\Carbon::createFromFormat('m-d-Y h:i A', $request->date . ' ' . $value);
                    if ($endDateTime->lte($startDateTime)) {
                        $fail('The end time must be after the start time.');
                    }
                },
            ],
            'no_of_attendees' => 'required|integer|min:1',
        ]);

        if ($validator->fails()) {
            return response()->json(['errors' => $validator->errors()], 422);
        }

        // Convert the date from m-d-Y to Y-m-d
        $date = \Carbon\Carbon::createFromFormat('m-d-Y', $request->date)->format('Y-m-d');

        // Convert start time and end time to 24-hour format (HH:mm:ss) before saving to the database
        $start_time = \Carbon\Carbon::createFromFormat('h:i A', $request->start_time)->format('H:i:s');
        $end_time   = \Carbon\Carbon::createFromFormat('h:i A', $request->end_time)->format('H:i:s');

        // Merge the converted values into the request
        $request->merge([
            'date'       => $date,
            'start_time' => $start_time,
            'end_time'   => $end_time,
        ]);

        // Find the slot and update it
        $slot = Slot::findOrFail($id);
        $slot->update($request->all());

        return response()->json(['success' => true]);
    }

    // Delete a specific slot from the database
    public function destroy($slotId)
    {
        DB::beginTransaction();

        try {
            $slot = Slot::findOrFail($slotId);

            // --- Get slot data for emails ---
            $oldSlot = $slot;

            // --- Collect all users (Leads + Participants) ---
            $sessionLeads = SessionLeads::where('slot_id', $slotId)
                ->with('user:id,name,email')
                ->get();

            $bookings = BookingHistory::where('slot_id', $slotId)
                ->with('user:id,name,email')
                ->get();

            // Merge both collections
            $allUsers = $sessionLeads->concat($bookings);

            // --- Save cancellation mails ---
            foreach ($allUsers as $entry) {
                if ($entry->user && $entry->user->email) {
                    $mailable = new \App\Mail\SlotCancellationMail($entry->user, $oldSlot);

                    CancellationMail::create([
                        'email'             => $entry->user->email,
                        'mail_template'     => $mailable->render(),
                        'role'              => $entry instanceof SessionLeads ? 1 : 2, // Lead or Participant
                        'subject'           => 'Slot Cancellation Notice',
                        'email_send_status' => 0,
                    ]);
                }
            }

            // --- Delete related data ---
            SessionLeads::where('slot_id', $slotId)->delete();
            BookingHistory::where('slot_id', $slotId)->delete();
            CancellationRequest::where('slot_id', $slotId)->delete();

            // --- Finally delete the slot ---
            $slot->delete();

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Slot and related data deleted successfully.',
            ]);

        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'success' => false,
                'message' => 'Failed to delete slot.',
                'error'   => $e->getMessage(),
            ]);
        }
    }

    public function showLeads(Slot $slot)
    {
        $leads = SessionLeads::where('slot_id', $slot->id)
            ->where('status', '!=', 5)
            ->with('user') // Assuming you have a relationship with the User model
            ->get();

        return view('slots.leads', compact('slot', 'leads'));
    }

    public function assignLead($encryptedSlot)
    {
        try {
            $slotId = Crypt::decrypt($encryptedSlot);
            $slot   = Slot::findOrFail($slotId);

            $leads = SessionLeads::where('slot_id', $slot->id)
                ->with('user')
                ->get();

            return view('slots.assign_lead', compact('slot', 'leads'));
        } catch (\Exception $e) {
            abort(404, 'Invalid slot link.');
        }
    }

    // public function approveLead(Request $request, $leadId)
    // {
    //     $lead = SessionLeads::find($leadId);

    //     if ($lead) {
    //         // Approve the lead
    //         $lead->status = 1; // Approved
    //         $lead->save();

    //         // Update the slot's status to approved
    //         $slot = $lead->slot; // Assuming a relationship exists
    //         if ($slot) {
    //             $slot->status = 1; // Approved
    //             $slot->save();
    //         }

    //         return response()->json(['success' => true, 'message' => 'Lead and slot approved successfully.']);
    //     }

    //     return response()->json(['success' => false, 'message' => 'Lead not found.'], 404);
    // }

    public function approveLead(Request $request, $leadId)
    {
        // Find the lead to be approved
        $lead = SessionLeads::find($leadId);

        if ($lead) {
            // Approve the lead (set status to 1)
            $lead->status = 1;
            $lead->save();

            // Get all other leads for the same slot
            $rejectedLeads = SessionLeads::where('slot_id', $lead->slot_id)
                ->where('id', '!=', $leadId) // Exclude the approved lead
                ->get();

            // Reject them and send rejection email
            foreach ($rejectedLeads as $rejected) {
                // ✅ Do not overwrite if status = 5 (previously cancelled by the user)
                if ($rejected->status != 5) {
                    $rejected->status = 2; // rejected
                    $rejected->save();

                    if ($rejected->user && $rejected->user->email) {
                        Mail::to($rejected->user->email)->send(new LeadRejectedMail($rejected));
                    }
                }
            }

                                 // Optionally, update the slot status
            $slot = $lead->slot; // Assuming relationship exists
            if ($slot) {
                $slot->status = 1;
                $slot->save();
            }

            // Send approval email
            if ($lead->user && $lead->user->email) {
                Mail::to($lead->user->email)->send(new LeadApprovedMail($lead));
            }

            /**
             * ✅ Only if admin checked "Send Mail"
             */
            if ($request->sendMail == 1) {
                $attendees = BookingHistory::with('user')
                    ->where('slot_id', $lead->slot_id)
                    ->whereHas('user', fn($q) => $q->where('role', 2)) // only participants
                    ->get();

                foreach ($attendees as $attendee) {
                    if ($attendee->user && $attendee->user->email) {
                        $htmlContent = View::make('emails.session_cancelled', [
                            'user' => $attendee->user,
                            'slot' => $lead->slot,
                        ])->render();

                        CancellationMail::create([
                            'email'             => $attendee->user->email,
                            'mail_template'     => $htmlContent,
                            'role'              => 2,
                            'subject'           => 'Session Cancelled',
                            'email_send_status' => 0,
                        ]);
                    }
                }
            }
            /**
             * Remove all attendees from booking history after admin changes lead
             */
            BookingHistory::where('slot_id', $lead->slot_id)->delete();

            return response()->json([
                'success' => true,
                'message' => 'Lead approved. Other leads rejected and notified by email.',
            ]);
        }

        return response()->json(['success' => false, 'message' => 'Lead not found.'], 404);
    }

    public function approve($id)
    {
        $slot         = Slot::findOrFail($id);
        $slot->status = 1;
        $slot->save();

        return response()->json(['success' => true, 'message' => 'Slot approved successfully.']);
    }

    public function markas_complete($id)
    {
        $slot = SessionLeads::find($id);

        if (! $slot) {
            return redirect()->back()->with('error', 'Slot not found or you do not have access to this slot.');
        }

        $slotdata = Slot::find($slot->slot_id);
        if (! $slotdata) {
            return redirect()->back()->with('error', 'Related slot not found.');
        }

        $slotdata->status = 2; // Completed
        $slotdata->save();

        $slot->status = 3; // Maybe means lead/session completed
        $slot->save();

        return redirect()->back()->with('success', 'The slot has been marked as completed.');
    }

    public function exportSlotsCSV()
    {
        $slots    = Slot::withTrashed()->get(); // If you want to include soft-deleted rows
        $filename = 'boost_slot_list_' . now()->format('Y-m-d') . '.csv';

        $headers = [
            'Content-Type'        => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"$filename\"",
        ];

        $columns = [
            'Name',
            'Date',
            'Start Time',
            'End Time',
            'Total Attendees Allowed',
            'Status',
            'Created At',
            'Updated At',
            'Deleted At',
        ];

        $callback = function () use ($slots, $columns) {
            $file = fopen('php://output', 'w');
            fputcsv($file, $columns);

            foreach ($slots as $slot) {
                fputcsv($file, [
                    $slot->name,
                    $slot->date,
                    $slot->start_time,
                    $slot->end_time,
                    $slot->no_of_attendees,
                    match ((int) $slot->status) {
                        0       => 'Pending',
                        1       => 'Approved',
                        2       => 'Completed',
                        default => 'Unknown',
                    },
                    $slot->created_at,
                    $slot->updated_at,
                    $slot->deleted_at,
                ]);
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    public function exportBookingHistoryCSV()
    {
        $histories = BookingHistory::with(['slot', 'user'])->get();

        $filename = 'boost_booking_history_' . now()->format('Y-m-d') . '.csv';

        $headers = [
            'Content-Type'        => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"$filename\"",
        ];

        $columns = [
            'S.No',
            'Slot Name',
            'Slot Date',
            'Slot Start Time',
            'Slot End Time',
            'User Name',
            'User Email',
            'Booking Status',
            'Created At',
            'Updated At',
            'Lead ',
        ];

        $callback = function () use ($histories, $columns) {
            $file = fopen('php://output', 'w');
            fputcsv($file, $columns);

            $serial = 1;

            foreach ($histories as $history) {
                // Get session leads for this slot
                $leads = SessionLeads::where('slot_id', $history->slot_id)->get();

                // Get lead user names + emails via user_id
                $leadDetails = $leads->map(function ($lead) {
                    $user = User::find($lead->user_id);
                    return $user
                    ? $user->name . ' (' . $user->email . ')'
                    : 'User ID: ' . $lead->user_id;
                })->implode('; '); // Delimit with semicolon

                fputcsv($file, [
                    $serial++,
                    optional($history->slot)->name,
                    optional($history->slot)->date,
                    optional($history->slot)->start_time,
                    optional($history->slot)->end_time,
                    optional($history->user)->name,
                    optional($history->user)->email,
                    match ((int) $history->status) {
                        0       => 'Pending',
                        1       => 'Approved',
                        2       => 'Rejected',
                        default => 'Unknown',
                    },
                    $history->created_at,
                    $history->updated_at,
                    $leadDetails,
                ]);
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    public function exportResetCSV()
    {
        $slots = Slot::with('sessionLeads')->withCount('bookinghistory')->get();

        $csvData = [];

        // Main header row
        $csvData[] = [
            'Slot Name',
            'Name',
            'Email',
            'Date',
            'Start Time',
            'End Time',
            'Total Attendees Allowed',
            'Registered Attendees Count',
            'Short Description', // New
            'Detail',            // New
        ];

        foreach ($slots as $slot) {
            // First row: Slot info + session description in Name column (or customize this)
            $csvData[] = [
                $slot->name,
                $slot->description ?? '-',
                '-',
                $slot->date,
                $slot->start_time,
                $slot->end_time,
                $slot->no_of_attendees,
                $slot->bookinghistory_count,
                '-', // Agenda placeholder
                '-', // Description placeholder
            ];

            // -- Attendees --
            $csvData[] = ['-- Attendees --'];

            $attendeeIds = BookingHistory::where('slot_id', $slot->id)->pluck('user_id');
            $attendees   = User::whereIn('id', $attendeeIds)->where('role', 2)->get();

            foreach ($attendees as $attendee) {
                $csvData[] = [
                    '',
                    $attendee->name,
                    $attendee->email,
                    '',
                    '',
                    '',
                    '',
                    '',
                    '',
                    '', // Empty agenda and description
                ];
            }

            // -- Leads --
            $csvData[] = ['-- Leads --'];

            if ($slot->sessionLeads) {
                $leadUser = User::find(optional($slot->sessionLeads->first())->user_id);
                if ($leadUser) {
                    $csvData[] = [
                        '',
                        $leadUser->name,
                        $leadUser->email,
                        '',
                        '',
                        '',
                        '',
                        '',
                        optional($slot->sessionLeads->first())->agenda ?? '-',
                        optional($slot->sessionLeads->first())->description ?? '-',
                    ];
                }
            }
        }

        // Create CSV
        $filename = 'Boost_Slots_Export_' . now()->format('m-d-y') . '.csv';
        $handle   = fopen('php://temp', 'r+');

        foreach ($csvData as $row) {
            fputcsv($handle, $row);
        }

        rewind($handle);
        $csvContent = stream_get_contents($handle);
        fclose($handle);

        return Response::make($csvContent, 200, [
            'Content-Type'        => 'text/csv',
            'Content-Disposition' => "attachment; filename={$filename}",
        ]);
    }

    public function exportSessions()
    {
        // Fetch session leads where status = 1 and not soft deleted
        $sessionLeads = SessionLeads::where('status', 1)
            ->whereHas('slot', function ($q) {
                $q->whereNull('deleted_at'); // Exclude soft-deleted slots
            })
            ->whereHas('user', function ($q) {
                $q->whereNull('deleted_at'); // Exclude soft-deleted users
            })
            ->with([
                'slot' => function ($q) {
                    $q->whereNull('deleted_at');
                },
                'user' => function ($q) {
                    $q->whereNull('deleted_at');
                },
            ])
            ->get();

        // Define CSV headers
        $headers = [
            'Slot Name',
            'Short Description',
            'Date',
            'Start Time',
            'End Time',
            'Description',
            'Lead Name',
        ];

        // Create CSV data
        $csvData   = [];
        $csvData[] = $headers;

        foreach ($sessionLeads as $lead) {
            $csvData[] = [
                $lead->slot->name ?? 'N/A',
                $lead->agenda,
                $lead->slot->date ?? 'N/A',
                $lead->slot->start_time ?? 'N/A',
                $lead->slot->end_time ?? 'N/A',
                $lead->description,
                $lead->user->name ?? 'N/A',
            ];
        }

        // Generate and return CSV file
        $filename = 'All_Sessions_' . now()->format('m-d-y') . '.csv';
        $handle   = fopen('php://temp', 'r+');

        foreach ($csvData as $row) {
            fputcsv($handle, $row);
        }

        rewind($handle);
        $content = stream_get_contents($handle);
        fclose($handle);

        return Response::make($content, 200, [
            'Content-Type'        => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"$filename\"",
        ]);
    }
}
