<?php
namespace App\Http\Controllers;

use App\Mail\SessionLeadRequestMail;
use App\Mail\SlotBookingCancellation;
use App\Mail\SlotBookingConfirmation;
use App\Mail\SlotWaitlistMail;
use App\Models\BookingHistory;
use App\Models\SessionLeads;
use App\Models\Slot;
use App\Models\User;
use Carbon\Carbon;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Mail;
use Illuminate\Validation\Rule;

class MemberController extends Controller
{
    /**
     * Create a new controller instance.
     *
     * @return void
     */
    // public function __construct()
    // {
    //     $this->middleware('auth');
    // }

    /**
     * Show the application dashboard.
     *
     * @return \Illuminate\Contracts\Support\Renderable
     */
    public function dashboard()
    {
        return view('frontend.members.dashboard');
    }

    public function howtousethissite()
    {
        return view('frontend.howtousethissite');
    }

    public function user_dashboard()
    {
        $userId = Auth::id();

        $approvedSlotCount = SessionLeads::with('slot')->where('status', 1)->where('user_id', $userId)->count();

        $pendingSlotCount = SessionLeads::with('slot')->where('status', 0)->where('user_id', $userId)->count();

        $recentleadsessions = SessionLeads::with('slot')->where('status', 1)->where('user_id', $userId)->limit('5')->get();

        $recentBookings = BookingHistory::with('slot')->where('user_id', $userId)->where('status', 1)->limit('5')->get();
        return view('frontend.members.user_dashboard', compact('recentleadsessions', 'recentBookings', 'approvedSlotCount', 'pendingSlotCount'));
    }

    public function change_password()
    {
        // Retrieve the authenticated user
        $user = Auth::user();

        // Pass the user data to the view
        return view('frontend.members.change_password', compact('user'));
    }

    public function updatePassword(Request $request, $id)
    {
        $validatedData = $request->validate([
            'current_password' => 'required',
            'new_password'     => [
                'required',
                'min:8',
                'regex:/^(?=.*[A-Za-z])(?=.*\d)(?=.*[^A-Za-z\d]).+$/',
            ],
            'confirm_password' => 'required|same:new_password',
        ], [
            'new_password.regex' => 'The new password must contain at least one letter, one number, and one special character.',
        ]);

        $user = User::findOrFail($id);

        if (! Hash::check($validatedData['current_password'], $user->password)) {
            return back()->withErrors(['current_password' => 'The current password is incorrect.']);
        }

        $user->password = Hash::make($validatedData['new_password']);
        $user->save();

        return redirect()->route('changepassword')->with('success', 'Password updated successfully.');
    }

    public function updateprofile(Request $request, $id)
    {
        $validatedData = $request->validate([
            'name'            => 'required',
            'email'           => [
                'required',
                'email',
                'regex:/^[a-zA-Z0-9._%+-]+@mit\.edu$/',                      // Only allow @mit.edu emails
                Rule::unique('users')->ignore($id)->whereNull('deleted_at'), // Ignore soft-deleted users
            ],
            'laboratory_name' => 'nullable',
        ]);

        $user = User::findOrFail($id);

        if ($request->hasFile('image')) {
            $imageExtension = $request->file('image')->getClientOriginalExtension();
            $imageName      = 'image_' . time() . '.' . $imageExtension;
            $request->file('image')->move(public_path('/admin/assets/images/'), $imageName);
            $user->image = $imageName;
        }

        $user->laboratory_name = $validatedData['laboratory_name'];
        $user->name            = $validatedData['name'];
        $user->email           = $validatedData['email'];

        $user->save();

        return redirect()->route('userprofile')->with('success', 'Profile updated successfully.');
    }

    public function unregister($id)
    {
        $user = User::findOrFail($id);

        // Soft delete the user
        $user->delete();

        // Log out the user
        Auth::logout();

        // Redirect to the homepage with a success message
        return redirect('/')->with('success', 'Your account has been deleted, and you have been logged out.');
    }

    public function checkActiveSlots()
    {
        $userId     = Auth::user()->id;
        $activeSlot = SessionLeads::where('user_id', $userId)
            ->where('status', '1')
            ->exists();
        return response()->json(['has_active_slot' => $activeSlot]);
    }

    public function userprofile()
    {
        $user = Auth::user();

        return view('frontend.members.userprofile', compact('user'));
    }

    public function leadmanagement(Request $request)
    {
        $userId = Auth::id();

        // Get dates from request
        $fromDate = $request->input('from_date');
        $toDate   = $request->input('to_date');

        $query = Slot::whereHas('sessionLeads', function ($query) use ($userId) {
            $query->where('user_id', $userId);
        });

        if ($fromDate && $toDate) {
            $query->whereBetween('date', [$fromDate, $toDate]);
        }
        $slots = $query->with([
            'sessionLeads' => function ($query) use ($userId) {
                $query->where('user_id', $userId);
            },
        ])->get();

        return view('frontend.members.leadmanagement', compact('slots'));
    }

    public function mySessions(Request $request)
    {
        $userId = Auth::id();

        $fromDate = $request->input('from_date');
        $toDate   = $request->input('to_date');

        // --------- Lead Sessions ---------
        $leadQuery = Slot::whereHas('sessionLeads', function ($q) use ($userId) {
            $q->where('user_id', $userId);
        });

        if ($fromDate && $toDate) {
            $leadQuery->whereBetween('date', [$fromDate, $toDate]);
        }

        $leadSlots = $leadQuery->with([
            'sessionLeads'        => function ($q) use ($userId) {
                // load ALL requests (old + new) for this user
                $q->where('user_id', $userId)->orderBy('id', 'asc');
            },
            'cancellationRequest' => function ($q) use ($userId) {
                $q->where('user_id', $userId)->where('cancellation_status', 0);
            },
        ])->get()->map(function ($slot) use ($userId) {
            // attach all session leads for this user
            $slot->role          = 'Leader';
            $slot->user_requests = $slot->sessionLeads->map(function ($lead) {
                return [
                    'status'      => $lead->status,
                    'lead_status' => $lead->status,
                    'description' => $lead->description,
                    'created_at'  => $lead->created_at,
                ];
            });
            // keep latest request status as "current"
            $latestLead                   = $slot->sessionLeads->last();
            $slot->status                 = $latestLead->status ?? 0;
            $slot->hasPendingCancellation = ! is_null($slot->cancellationRequest);
            return $slot;
        });

        // --------- Participant Sessions ---------
        $participantSlots = BookingHistory::with('slot')
            ->where('user_id', $userId)
            ->whereIn('status', [1, 2])
            ->get()
            ->filter(fn($booking) => $booking->slot)
            ->map(function ($booking) {
                $slot                  = $booking->slot;
                $slot->role            = 'Participant';
                $slot->status          = $booking->status;
                $slot->description     = $slot->description ?? '';
                $slot->booking_id      = $booking->id;
                $slot->booking_history = $booking; // ✅ attach booking_history relation
                return $slot;
            });

        return view('frontend.members.mysession', compact('leadSlots', 'participantSlots', 'fromDate', 'toDate'));
    }

    public function store(Request $request)
    {
        try {
            // Validate input
            $validated = $request->validate([
                'slot_id'       => 'required|exists:slots,id',
                'agenda'        => 'required|string|max:255',
                'description'   => 'required|string',
                'other_details' => 'nullable|string',
            ]);

            // Save session lead
            SessionLeads::create([
                'user_id'       => auth()->id(),
                'slot_id'       => $validated['slot_id'],
                'agenda'        => $validated['agenda'],
                'description'   => $validated['description'],
                'other_details' => $validated['other_details'],
            ]);

            $slot = Slot::find($validated['slot_id']);
            $user = User::find(auth()->id());

            $agenda       = $validated['agenda'];
            $description  = $validated['description'];
            $otherDetails = $validated['other_details'] ?? 'N/A';

            // Get all admin users
            $admins = User::where('role', 1)->get();

            // 1️⃣ Send to all admins
            foreach ($admins as $admin) {
                Mail::to($admin->email)->send(new SessionLeadRequestMail($user, $slot, $agenda, $description, $otherDetails));
            }

            // 2️⃣ Send to the booking user
            // Mail::to($user->email)->send(new SessionLeadRequestMail($user, $slot, $agenda, $description, $otherDetails));

            return response()->json(['success' => true, 'message' => 'Slot booked, admin and user notified.']);
        } catch (\Exception $e) {
            return response()->json(['success' => false, 'message' => $e->getMessage()]);
        }
    }

    public function checkSlotStatus(Request $request)
    {
        $slot = Slot::find($request->slot_id);

        if (! $slot) {
            return response()->json(['success' => false, 'message' => 'Slot not found.']);
        }

        if ($slot->status == 1) {
            return response()->json(['success' => false, 'message' => 'This slot has already been booked.']);
        }

        return response()->json(['success' => true]);
    }

    public function availableslots(Request $request)
    {
        $userId = Auth::id();

        try {
            // Check if dates are provided or fetch all records
            $fromDate = $request->input('from_date')
            ? Carbon::createFromFormat('m-d-Y', $request->input('from_date'))->format('Y-m-d')
            : null;

            $toDate = $request->input('to_date')
            ? Carbon::createFromFormat('m-d-Y', $request->input('to_date'))->format('Y-m-d')
            : null;
        } catch (\Exception $e) {
            return back()->withErrors(['error' => 'Invalid date format provided.']);
        }

        // Build the query
        $query = Slot::with([
            'sessionLeads' => function ($query) use ($userId) {
                $query->where('user_id', $userId)->where('status', 0);
            },
        ])->where('status', 0);

        // Apply date filters if provided
        // if ($fromDate && $toDate) {
        //     $query->whereBetween('date', [$fromDate, $toDate]);
        // }

        // Fetch results
        $slots = $query->get();

        return view('frontend.members.availableslots', compact('slots'));
    }

    public function book_session_list(Request $request)
    {
        $userId = Auth::id();

        try {
            // Parse incoming dates or set defaults
            $fromDate = $request->input('from_date')
            ? Carbon::createFromFormat('m-d-Y', $request->input('from_date'))->format('Y-m-d')
            : null;

            $toDate = $request->input('to_date')
            ? Carbon::createFromFormat('m-d-Y', $request->input('to_date'))->format('Y-m-d')
            : null;
        } catch (\Exception $e) {
            return back()->withErrors(['error' => 'Invalid date format provided.']);
        }

        // Query slots without existing bookings for the current user
        $query = Slot::where('status', 1)
            ->whereDate('date', '>=', Carbon::today())
            ->whereDoesntHave('booking_history', function ($query) use ($userId) {
                $query->where('user_id', $userId)->where('status', 1);
            });

        // Apply date filters if provided
        if ($fromDate && $toDate) {
            $query->whereBetween('date', [$fromDate, $toDate]);
        }

        // Fetch results
        $slots = $query->get();

        return view('frontend.members.bookinglist', compact('slots'));
    }

    public function bookingHistorylist(Request $request)
    {
        $userId = Auth::id();

        // Build the query
        $query = Slot::whereHas('bookinghistory', function ($query) use ($userId) {
            $query->where('user_id', $userId)->where('status', 1);
        })->where('status', '!=', 1);

        $slots = BookingHistory::with('slot')->where('user_id', $userId)->where('status', 1)->get();
        // dd($slots);
        return view('frontend.members.bookingHistorylist', compact('slots'));
    }

    public function cancelBookingById($id, $slot_id)
    {
        $bookingHistory = BookingHistory::where([
            ['user_id', Auth::user()->id],
            ['id', $id],
        ])->first();

        if ($bookingHistory) {
            $bookingHistory->delete();

            // Send cancellation email
            $user = Auth::user();
            $slot = Slot::with('sessionLeads')->find($slot_id);

            if ($slot) {
                Mail::to($user->email)->send(new SlotBookingCancellation($user, $slot));
            }

            $pendingBooking = BookingHistory::where([
                ['slot_id', $slot_id],
                ['status', 2],
            ])->orderBy('created_at', 'asc')->first();

            if ($pendingBooking) {
                $pendingBooking->status = 1;
                $pendingBooking->save();

                $session_lead = SessionLeads::where('slot_id', $slot_id)->where('status', 1)->first();

                $emailData = [
                    'user'          => User::find($pendingBooking->user_id),
                    'slot_id'       => $slot_id,
                    'agenda'        => $session_lead->agenda,
                    'description'   => $session_lead->description,
                    'other_details' => $session_lead->other_details,
                ];

                // Send email
                // Mail::to('bcs-boost@mit.edu')->send(new SendEmail($emailData));
                // Send confirmation email to the newly confirmed user
                $confirmedUser = User::find($pendingBooking->user_id);
                $slot          = Slot::find($slot_id); // fetch slot info
                Mail::to($confirmedUser->email)->send(new SlotBookingConfirmation($confirmedUser, $slot));
            }

            return redirect()->route('user.my_sessions')->with('success', 'Booking canceled successfully.');
        } else {
            return redirect()->route('user.my_sessions')->withErrors(['error' => 'Booking not found.']);
        }
    }

    public function bookasession(Request $request)
    {
        $request->validate([
            'slot_id' => 'required|exists:slots,id',
        ]);

        $userId = Auth::id();

        // Check if already booked
        $existingBooking = BookingHistory::where('slot_id', $request->slot_id)
            ->where('user_id', $userId)
            ->whereIn('status', [0, 1, 2]) // any booking (pending, confirmed, waitlist)
            ->first();

        if ($existingBooking) {
            return response()->json(['success' => false, 'message' => 'You have already booked this slot.'], 400);
        }

        $slot = Slot::find($request->slot_id);
        if (! $slot) {
            return back()->withErrors(['error' => 'Slot not found.']);
        }

        // Count total confirmed bookings for this slot
        $currentBookings = BookingHistory::where('slot_id', $request->slot_id)
            ->where('status', 1) // only confirmed
            ->count();

        $user = auth()->user();

        if ($currentBookings < $slot->no_of_attendees) {
            // Confirm booking
            $booking = BookingHistory::create([
                'slot_id' => $request->slot_id,
                'user_id' => $userId,
                'status'  => 1, // confirmed
            ]);

            // Send confirmation email
            Mail::to($user->email)->send(new SlotBookingConfirmation($user, $slot));

            return response()->json([
                'success' => true,
                'markas'  => '1',
                'message' => 'Booking confirmed successfully!',
            ], 200);

        } else {
            // Waitlist booking
            $booking = BookingHistory::create([
                'slot_id' => $request->slot_id,
                'user_id' => $userId,
                'status'  => 2, // waitlisted
            ]);

            // Send waitlist email
            Mail::to($user->email)->send(new SlotWaitlistMail($user, $slot));

            return response()->json([
                'success' => true,
                'markas'  => '2',
                'message' => 'This session is now at capacity. You have been waitlisted.',
            ], 200);
        }
    }

}
